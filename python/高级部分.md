[TOC]

# python函数

## 函数 

> 函数：可以实现一些特定功能的小方法或是小程序。 
>
> python函数: 完成一定的功能,由若干语句组成的语句块, 函数名称, 参数列表构成, 它是组织代码的最小单位。

**作用** 

> 结构化变成对代码的最基本的封装, 一般按照功能组织一段代码。 
>
> 封装的目的为了复用, 减少冗余代码。 
>
> 代码更加简洁美观,可读易懂。

**总结**

> 函数是可调用的对象,callable()。 

### 函数参数 

1、参数调用时传入的参数要和定义的个数相匹配。 

2、位置参数：按照参数定义顺序传入实参。 

3、关键字参数: 使用形参的名字来传入实参的方式,如果使用了形参名字,那么传参顺序就可以和定义顺序不同。

注: **参数列表参数一般顺序是,普通参数,缺省参数,可变位置参数,keyword-only参数(可带缺省值),可变关键字参数.**

### 函数参数默认值 

> 参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值。
>
> 参数非常多时,并不需要用户每次都输入所有的参数,简化函数调用。 

### 可变参数 

**可变参数分为位置可变参数和关键字可变参数。**

> 一个形参可以匹配任意个参数。 
>
> 在形参前使用 ` *` 表示该形参是可变参数,可以接收多个实参。
> 收集多个实参为一个**元组**。
>
> ```python 
> def func(*形参)：  
> 	pass  
> func(实参) 
> ```

**关键字参数的可变参数**

> 形参前使用 `**` 符号,表示可以接收多个关键字参数。 
>
> 收集的实参名称和值组成一个**字典**。

**可变参数混合使用** 

> 混合使用参数时,可变参数要放在参数列表的最后,普通参数需要放到参数列表前面,位置可变参数需要放在关键字可变参数之前。
>
> ```python 
> def showconfig(username,password,**kwargs) 
> def showconfig(username,*args,**kwargs)
> def showconfig(username,password,**kwargs,*args)
> ```

### keyword-only参数

注: python3.x 新加入。

> 在一个带星号的参数后, 或者一个位置可变参数后, 出现的普通参数即 keyword-only 参数。
>
> ```python 
> # 例 
> def fn(*,x,y): 
>     pass  
> fn(x=4, y=5)
> ```

### 参数解构

> 给函数提供实参时,可在集群类型前使用*或**,把集群类型的元素解开,提取出所有元素作为函数的实参。
>
> 非字典类型使用 `*` 解构成位置参数。
>
> 字典类型使用 `**` 解构成关键字参数。
>
> 提取出来的元素数目要和参数的要匹配, 也要和参数的类型匹配。

```python 
In [1]: import random

In [2]: def double_values(*nums):
   ...:     print(nums)
   ...:     return max(nums), min(nums)
   ...:

In [3]: print(*double_values(*[random.randint(10, 20) for _ in range(10)]))  # 两次解构.
(15, 12, 15, 13, 20, 11, 13, 20, 18, 13)
20 11

In [4]:
```



## 插入排序



## 函数的返回值, 作用域 

### 函数返回值 

> 作用: 结束函数调用和返回返回值。
>
> `返回值` 使用return语句返回。 
>
> 所有函数都有函数值,如果没有 return 语句,隐式调用 `return None`。 
>
> 一个函数可以存在多个return语句, 但是只有一条可以被执行。
>
> 如果函数执行了return语句,函数就会返回,当前被执行的return语句之后的其他语句就不会被执行。

### 函数嵌套 

> 函数有可见范围,这就是 `作用域` 的概念。
> 内部函数不能被外部直接使用,会抛异常 NameError 。

### 函数作用域

> 作用域: 一个标识符的可见范围即标识符的作用域.一般常说的是变量的作用域。 
>
> - 全局作用域: 在整个程序运行环境中都可见。 
>
> - 局部作用域: 在函数, 类等内部可见。 
>
>   局部变量使用范围不能超过其所在的局部作用域。
>
>   如果是多层函数嵌套，外层变量作用域在内层作用域可见。 

**global - 全局变量**  

> 使用 global 关键字的变量, 将函数内部的变量声明为函数外的全局作用域中的变量。
>
> 如果全局作用域中没有该局部作用域定义的变量，使用global后，相当于在全局作用域中定义且赋值了一个变量对应的值。如果全局作用域中已有该变量，则会覆盖。
>
> global使用原则: 
>
> - 外部作用域变量在内部作用域可见, 但也不要在这个内部的局部作用域中直接使用, 因为函数的目的就是为了封装, 尽量与外界隔离。
> - 如果函数需要使用外部全局变量, 使用函数的形参传参解决。

### 闭包 

> 自由变量: 未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量。
> 闭包: 是一个概念, 出现在嵌套函数中, **内层函数引用到外层函数的自由变量**, 就形成了闭包, JS就是如此。 

示例: 

```python 
In [1]: def func1():
    ...:     count = 0
    ...:     def inc1():
    ...:         count += 1  # 该处报错问题, 使用global可以解决,但这样使用的是全局变量,而不是闭包。 
    ...:         return count
    ...:     return inc
    ...:

In [2]: 
```

该counter函数会报错 `UnboundLocalError` 。

```python 
In [3]: def func2():
   ...:     count = [0]
   ...:     def inc2():
   ...:         count[0] += 1  # 该处的使用方式为count的元素修改值,而不是重新定义变量。 
   ...:         return count[0]
   ...:     return inc
    
In [4]:
```

该counter函数不会报错。

**总结** 

> 1、内部函数，不修改全局变量可以访问全局变量；在内部函数里面修改同名全局变量，则python会认为该变量就是一个局部变量；在内部函数修改同名全局变量之前调用变量名称，则引发 `UnboundLocalError`。
>
> 2、在程序中设置的 count 属于全局变量, 而在嵌套函数中没有 count 的定义,根据python访问局部变量和全局变量的规则：当搜索一个变量的时候，python先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，python就在全局变量中找这个变量，如果找不到抛出异常(NameError或者UnboundLocalError，这取决于python版本。) 
>
> 3、如果内部函数有引用外部函数的同名变量或者全局变量, 并且对这个变量有修改, 那么python会认为它是一个局部变量,又因为函数中没有 count 的定义和赋值, 所以报错。

### nonlocal 关键字

> 用来在函数或其他作用域中使用外层(非全局)变量。
>
> 使用了nonlocal关键字, 即把变量标记为在上级的局部作用域中定义的变量, 但不能是全局作用域中定义的.

```python 
In [1]: def counter():
   ...:     count = 0
   ...:     def inc():
   ...:         nonlocal count
   ...:         count += 1
   ...:         return count
   ...:     return inc
   ...:

In [2]: res = counter()

In [3]: res()
Out[3]: 1

In [4]: res()  # 变量count的值伴随着这个函数对象的整个生命周期。
Out[4]: 2

In [5]:
```

### 默认值的作用域 

示例1： 

```python 
In [1]: def foo(lst=[]):
   ...:     lst.append(1)
   ...:     return lst
   ...:

In [2]: foo.__defaults__
Out[2]: ([],)

In [3]: foo()
Out[3]: [1]

In [4]: foo.__defaults__
Out[4]: ([1],)

In [5]: foo()
Out[5]: [1, 1]

In [6]: foo.__defaults__
Out[6]: ([1, 1],)
# 函数也是对象,python把函数的默认值放在了属性中,这个属性就伴随着这个函数对象的整个生命周期。
```

示例2：引用类型

```python 
In [7]: def foo(xyz=[], u='abc', z=123):
    ...:     xyz.append(1)
    ...:     return xyz
    ...:

In [8]: foo(), id(foo)
Out[8]: ([1], 2239176151928)

In [9]: foo.__defaults__
Out[9]: ([1], 'abc', 123)

In [10]: foo(), id(foo)
Out[10]: ([1, 1], 2239176151928)

In [11]: foo.__defaults__
Out[11]: ([1, 1], 'abc', 123)

In [12]:
# 函数地址并没有变,即函数这个对象的地址没有变,调用它,它的属性__defaults__中使用元组保存所有默认值. 
# xyz默认值是引用类型,引用类型的元素变动,并不是元组的变化。 
```

示例3：非引用类型

```python 
In [1]: def foo(w,u='abc',z=123):
   ...:     u='xyz'
   ...:     z=789
   ...:     print(w,u,z)
   ...:

In [2]: foo.__defaults__
Out[2]: ('abc', 123)

In [3]: foo('amesy')
amesy xyz 789

In [4]: foo.__defaults__
Out[4]: ('abc', 123)

# 属性__defaults__中使用元组保存所有默认值,__defaults__不会因为在函数体内使用了它而发生改变。 
# 可变类型默认值,如果使用默认值,就可能修改这个默认值。
# 有时候这个特性是好的,有时候不然,有副作用。
```

示例4：按需改变

```python 
def foo(xyz=[], u='abc', z=123):
	xyz = xyz[:] # 影子拷贝.
	xyz.append(1)
	print(xyz)

# 使用影子拷贝创建一个新的对象,永远不能改变传入的参数。
```

```python 
def foo(xyz=None, u='abc', z=123):
    if xyz is None:
        xyz = []
    xyz.append(1)
    print(xyz)
    
# 通过值的判断就可以灵活的选择创建或修改传入对象。 
# 这种方式灵活,应用广泛。很多函数的定义,都会使用None这个不可变的值作为默认参数,算是一种惯用法。
```

### 变量名解析原则LEGB

- Local, 即本地作用域, 局部作用域的local命名空间。函数调用时创建, 调用结束消亡。 
- Enclosing, python2.2时引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间。 
- Global, 全局作用域, 即一个模块的命名空间。模块被import时创建, 解释器退出时消亡。 
- Build-in, 内置模块的命名空间, 生命周期从python解释器启动时创建到解释器退出时消亡。
  - 例如print(open),print和open都是内置的变量. 

   所以一个名词的查找顺序就是 `LEGB` 。

   图示:

  ​	![LEGB](http://static.open-open.com/lib/uploadImg/20150209/20150209125753_178.jpg)

### 函数的销毁

全局函数销毁: 

- 重新定义同名函数。 
- del语句删除函数对象。
- 程序结束时自然消亡。 

局部函数销毁: 

- 重新在上级作用域定义同名函数。


- del语句删除函数对象。
- 上级作用域销毁时。

## 树 



## 函数代码的执行流程 

> 函数的执行总是从程序的第一行代码开始的，从上到下，从左到右，从第一条语句开始按顺序依次执行。
>
> 函数定义并不会改变程序的执行流程，但应该注意函数代码块中的语句并不是立即就执行的，而是等到函数被程序调用时才会执行。
>
> 函数调用可以看作程序执行流程中的一个迂回路径，遇到函数调用时，并不会直接继续执行下一条语句，而是跳到函数体的第一行，继续执行完函数代码块的所有语句，再跳回到原来离开的地方。
>
> 函数代码块中也可以调用其他函数，当程序流程运行到一个函数之中时，可能需要执行其他函数中的语句; 但当执行那个函数中的语句时，又可能再需要调用执行另一个函数的语句。
>
> Python对于它运行到哪里有记录，所以在每个函数执行结束之后，程序都能跳回到它离开的那个地方, 直至执行到整个程序的结尾，才会结束程序。
>

动态演示函数的执行过程: <http://pythontutor.com/visualize.html#mode=edit>

## 递归函数 

> ​    函数直接或间接调用自身即递归。
>
> ​    递归需要有边界条件,递归前进段, 递归返回段。 
>

递归动态图示:  http://codingpy.com/article/10-gifs-to-understand-some-programming-concepts/

示例：斐波那契数列 

```python 
# 如果设F(n)为该数列的第n项,(n∈N-1),那么这句话可以写成:F(n) = F(n-1) + F(n-2) 
def fn(n): 
    return 1 if n < 2 else fn(n-1) + fn(n-2) 
```

实例: 阶乘的递归 

```python 
def fn(n): 
	if n == 0:
		raise ValueError('0 is invaild') 
	elif n == 1: 
		return 1
	return n * fn(n-1)
```

注: 

- 递归一定要有退出条件,递归调用一定要执行到这个退出条件；没有退出条件的递归调用就是无限调用。
- python对递归调用的深度做了限制, 超过递归深度限制, 会抛异常。`sys.getrecursionlimit() `

**递归函数的性能**

- 深度越深, 效率越低。
- 递归有深度限制, 如果递归复杂, 函数反复压栈, 栈内存很快就溢出了。  

示例：对斐波那契数列的改进 

```python 
pre = 0
cur = 1
def fib(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib(n-1, pre, cur)
```

**间接递归** 

> 通过别的函数调用了函数自身, 即间接递归。 
> 在复杂代码情况下发生间接递归调用是非常危险的, 要用代码规范来避免这种递归调用的发生。 

**总结** 

递归是一种很自然的表达,符合逻辑思维。
递归相对运行效率低,每一次调用函数都要开辟栈帧。
递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了。
如果是有限次数的递归,可以使用递归调用,或者使用循环代替,循环代码稍微要复杂一些,但是只要不是死循环,可以多次迭代直至算出结果。
绝大多数递归,都可以使用循环实现。
即使递归代码很简洁,但是能不用递归就不要用。

## 高阶函数

> 概念: 把函数当成参数传递的一种函数。 
>
> 满足要求: 接收一个或多个函数作为参数，输出一个函数。(两者满足其一即可)

示例： 

```python 
In [1]: def add(x, y, func):
   ...:     return func(x) + func(y)
   ...:

In [2]: add(-8, 11, abs)
Out[2]: 19
```

示例: 计数器 

```python 
In [9]: def counter(base):
   ...:     def inc(step=1):
   ...:         nonlocal base  # 该行没有的话会报错。
   ...:         base += step
   ...:         return base
   ...:     return inc
   ...:

In [10]: print(counter(5)())
6
In [11]:
```

分析: 

- 该 counter 是一个高阶函数,  第4行base被重新赋值, 所以需要nonlocal关键字。 
- 对于 `f1 = counter(5)` 和 `f2 = counter(5)` , 值相同但内存地址不同。因为 inc 是 counter内的函数, 每次调用counter时, inc都要在栈上重新生成, 故内存地址不相等。


示例: 自定义 sort 函数 

>   排序问题: 仿照内建函数sorted, 实现一个sort函数(不使用内建函数), 且能够为列表元素排序。 
>   思路: 
>
>   -   内建函数sorted会返回一个新的列表,可以设置升序或降序,设置的排序的函数,自定义的sort函数也要实现这个功能。
>   -   新建一个列表, 遍历原列表, 和新列表的值依次比较决定如何插入到新列表中。 

```python 
def sort(iterable, reverse=False):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            bol = x > y if reverse else x < y
            if bol:
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst, reverse=True))
```

```python 
def sort(iterable, fn = lambda x, y: x < y):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            if fn(x, y):
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst))
```


## 匿名函数 

> 匿名函数,即没有名字的函数。 
>
> python借助 lambda 表达式构建匿名函数；它只能写在一行上,被称为单行函数。
>
> 格式:  `lambda 参数列表: 表达式 `
>
> - 参数列表不需要小括号。
> - 冒号用来分割参数列表和表达式。
> - 不需要使用return,表达式的值,就是匿名函数返回值. 
> - lambda表达式(匿名函数)只能写在一行上,被称为单行函数。

```python 
In [4]: print((lambda x, *, y=30: x + y)(5, y=10))
15

In [5]: print((lambda *args: (x for x in args))(*range(5)))
<generator object <lambda>.<locals>.<genexpr> at 0x000001E699027888>

In [6]: print((lambda *args: [x for x in args])(*range(5)))
[0, 1, 2, 3, 4]

In [9]: print((lambda *args: {x for x in args})(*range(5)))
{0, 1, 2, 3, 4}
```

## map()函数 

> python内置的一个高阶函数, 它接收一个函数和一个列表, 并且把列表的元素以此传递给该函数，然后返回一个该函数处理完所有列表元素的迭代器。

```python 
In [11]: list(map(lambda x: x**2, [1, 2, 3, 4]))
Out[11]: [1, 4, 9, 16]

In [12]:
```

示例: 在高阶函数传参时,使用lambda表达式, 简化代码。

```python
In [14]: [x for x in (lambda *args: map(lambda x: x**2, args))(*range(5))]
Out[14]: [0, 1, 4, 9, 16]
```

```python
In [15]: [x for x in (lambda *args: map(lambda x: (x+1,args), args))(*range(5))]
Out[15]:
[(1, (0, 1, 2, 3, 4)),
 (2, (0, 1, 2, 3, 4)),
 (3, (0, 1, 2, 3, 4)),
 (4, (0, 1, 2, 3, 4)),
 (5, (0, 1, 2, 3, 4))]
```

## filter()函数

>   python内置的高阶函数, 过滤可迭代对象的元素, 返回一个迭代器。用法和map函数类似。 

```python 
In [1]: list(filter(lambda x: x %3 == 0, [0, 3, 4, 7, 9]))
Out[1]: [0, 3, 9]

In [2]:
```

## 柯里化Currying 

>   指将原来接收两个参数的函数变成新的接收一个参数的函数的过程, 新的函数返回一个以原有第二个参数为参数的函数。  
>   即 `z = f(x, y)` 转换成 `z = f(x)(y)` 的形式。  

示例: 通过嵌套函数就可以把函数转换为柯里化函数。

```python 
def add(x, y):
    return x + y

print(add(5, 4))
 
# 以上代码通过柯里化, 改为如下: 
def add(x):
    def _add(y):
        return x + y
    return _add

print(add(5)(4))
```

# 生成器 

- 带有 **yield** 关键字的的函数在 Python 中被称之为 generator(生成器)。Python 解释器会将带有 **yield** 关键字的函数视为一个 generator 来处理。一个函数或者子程序都只能 return 一次，但是一个生成器能暂停执行并返回一个中间的结果 —— 这就是 yield 语句的功能 : 返回一个中间值给调用者并暂停执行。
- **生成器其实是一种特殊的迭代器**，这句话反过来不成立。不过这种迭代器更加优雅, 它不需要再像上面的类一样写 `__iter__()`和 `__next__()`方法了，只需要一个 `yiled`关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。



```python 
# generator
def arr(num):
    n, a, b = 0, 0, 1
    while n < num:
        yield b
        a, b = b, a+b
        n += 1
res = arr(5)
for _ in range(5):
    print(next(res))
```

**分析：生成器 arr() 的执行过程**

- 执行语句 res = arr(5) 时，并不会马上执行 arr() 函数的代码块，而是首先返回一个 iterable 对象。
- 在 for 循环语句执行时，才会执行 fab() 函数的代码块。 
- 执行到语句 yield b 时，fab() 函数会返回一个迭代值，直到下次迭代前，程序流会回到 yield b 的下一条语句继续执行，然后再次回到 for 循环，如此迭代直到结束。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 
- 由此可以看出，**生成器通过关键字 yield 不断的将迭代器返回到内存进行处理，而不会一次性的将对象全部放入内存，从而节省内存空间**。从这点看来生成器和迭代器非常相似，但如果更深入的了解的话，其实两者仍存在区别。

## 生成器函数 

> 函数体中包含yield语句的函数,返回生成器对象. 
>
> - 生成器对象,是一个可迭代对象, 也是一个迭代器。
> - 生成器对象,是延迟计算,惰性求值的。
>
> 生成器函数等价于生成器表达式,只不过生成器函数可以更加的复杂。
>
> 在一个生成器函数中, 如果没有 return, 则默认执行至函数完毕, 如果在执行过程中 return, 则会直接抛出 `StopIteration` 来终止迭代。

判断一个函数是否为generator函数, 使用isgeneratorfunction判断。

```python 
In [1]: def func(b):
    ...:     yield b
    ...:
    ...:

In [2]: from inspect import isgeneratorfunction

In [3]: isgeneratorfunction(func)
Out[3]: True
```

**注意区分 func 和 func(b)** ，`func` 是一个 generator function，而 `func(b)` 是调用 fab 返回的一个 generator。 

```python 
In [4]: from collections import Iterable

In [5]: isinstance(func, Iterable)
Out[5]: False

In [6]: isinstance(func(4), Iterable)
Out[6]: True

In [7]: 
```

示例: 处理递归问题。

```python  
def fib():
    x = 1
    y = 1
    while True:
        yield x
        x, y = y, x+y
foo = fib()
for _ in range(10):
    print(next(foo))
```

```python 
pre = 0
cur = 1
print(pre, cur, end = ' ')

def fib1(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib1(n-1, pre, cur)
    
fib1(10)
```

## 生成器表达式 

> 生成器表达式是列表解析的扩展，就如上所述：生成器是一个特定的函数, 允许返回一个中间值，然后挂起代码的执行，稍后再恢复执行。列表解析的不足在于，它必须一次性生成所有的数据，用以创建列表对象，所以不适用于迭代大量的数据。 **生成器表达式则通过结合列表解析和生成器来解决这个问题。**

**语法** 

```python 
# 列表解析式 
[expr for iter_var in iterable if cond_expr] 

# 生成器表达式 
(expr for iter_var in iterable if cond_expr)
```

**总结** 

> 两者的语法非常相似，但生成器表达式返回的不是一个列表类型对象，而是一个生成器对象，生成器是一个内存使用友好的结构。在需要迭代一个对象时，应该优先考虑使用生成器替代迭代器，使用生成器表达式替代列表解析。当然这并不是绝对的。迭代器和生成器是 Python 很重要的特性，对其有很好的理解能够写出更加 Pythonic 的代码。

## 协程coroutine: 

> 属于生成器的高级用法。 
>
> 比进程,线程轻量级。 
>
> 是在用户空间调度函数的一种实现。 
>
> python3 asyncio 就是协程实现,已经加入到标准库。
>
> python3.5使用 `async`, `await` 关键字直接原生支持协程。 

**协程调度实现思路**

>   有2个生成器A, B, next(A)后,A执行到yield语句暂停, 然后执行next(B), B执行到yield语句也暂停, 就再次调用next(A), 然后再调用next(B), 周而复始, 就实现了调度的效果。 

- 可以引入调度的策略来实现切换的方式。 
- 协程是一种非抢占式调度。
- 另一个 yield 的例子来源于文件读取。如果直接对文件对象调用 read() 方法, 会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。
- 通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取。

```python
def read_file(fpath):
   BLOCK_SIZE = 1024
   with open(fpath, 'rb') as f:
       while True:
           block = f.read(BLOCK_SIZE)
           if block:
               yield block
           else:
               return 
```

### yield from 

>   `yield from` 是 python3.3 出现的新的语法。
>
>    `yield from iterable` 是 `for item in iterable: yield item` 形式的语法糖。
>
>   使用于

```python 
def inc():
    for x in range(10):
        yield x

# 等价于

def inc():
    yield from range(10)

foo = inc()
for _ in range(10):
    print(next(foo))
```

# 装饰器 

## 无参装饰器 

```python 
def add(x, y):
    return x+y

def func(fn, *args, **kwargs):
    print('begin')
    res = fn(*args, **kwargs)
    print('end')
    return res

print(func(add, 4, y=5))
```

## 装饰器语法糖

>   装饰器(无参)：
>
>   -   是一个函数; 
>   -   函数作为它的形参; 
>   -   返回值也是一个函数; 
>   -   使用 `@FunctionName` 方式, 简化调用; 
>   -   可以使用特殊属性 `__name__` 查看函数名。
>
>   装饰器和高阶函数：
>
>   -   装饰器是高阶函数, 但装饰器是对传入函数的功能的装饰(即功能增强). 

```python 
import datetime
import time

def logger(fn):
    def wrap(*args, **kwargs):
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)
    return wrap

@logger  # add = logger(add)

def add(x, y):
    time.sleep(1)
    return x + y

print(add(4, 5))
```

## 文档字符串

>   在函数语句块的第一行, 且习惯是多行的文本, 一般使用三引号。   
>
>   惯例是首字母大写, 第一行写概述, 然后空一行, 第三行写详细描述。 
>
>   可以使用特殊属性 `__doc__` 访问这个文档。 

```python 
def add(x, y):
    """ This is a function addition"""
    return x + y

print('result: {}, function_name: {}, Document_desc: {}'.format(add(4, 5), add.__name__, add.__doc__)
```

```python
import datetime
import time

def copy_properties(src, dst):
    dst.__name__ = src.__name__
    dst.__doc__ = src.__doc__

def logger(fn):
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    copy_properties(fn, wrap)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

上面的函数, 如果没有 `copy_properties`，原函数 `add`对象的属性都会被替换成 `wrap` ; 因此提供 `copy_properties`函数, 被封装函数属性 –> copy -> 包装函数属性。通过 `copy_properties` 函数用被包装函数的属性覆盖掉包装函数。凡是被装饰的函数都需要复制这些属性, 这个函数很通用, 可以将复制属性的函数构建成装饰器函数, 带参装饰器。 

## 带参装饰器 

>   它是一个函数, 函数作为它的形参。返回值是一个不带参的装饰器函数, 使用 `@functionname (参数列表)` 方式调用。可以看做在装饰器外层又加了一层函数. 

示例: 将记录的功能提取出来,就可以通过外部提供的函数来灵活控制输出。

```python 
import datetime
import time

def copy_properties(src):
    def _copy(dst):
        dst.__name__ = src.__name__
        dst.__doc__ = src.__doc__
        return dst
    return _copy

def logger(fn):
    @copy_properties(fn)
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

# functools模块

>   Python自带的 `functools` 模块提供了一些常用的高阶函数，也就是用于处理其它函数的特殊函数。换言之，就是能使用该模块对可调用对象进行处理。

## update_wrapper()

该函数用于更新包装函数（wrapper），使它看起来像原函数一样, 类似于上面代码中的 `copy_properties` 。该函数主要用在装饰器函数的定义中，置于包装函数之前。如果没有对包装函数进行更新，那么被装饰后的函数所具有的元信息就会变为包装函数的元信息，而不是原函数的元信息。

```python 
# 语法 
update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)) 
```

可选的参数是一个元组，`assigned` 元组指定要直接使用原函数的值进行替换的属性，`updated` 元组指定要对照原函数进行更新的属性。这两个参数的默认值分别是模块级别的常量：`WRAPPER_ASSIGNMENTS` 和 `WRAPPER_UPDATES`。前者指定了对包装函数的 `__name__`, `__module__`, `__doc__` 属性直接赋值，而后者指定了对包装函数的 `__dict__` 属性进行更新。

示例：属性复制.

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return functools.update_wrapper(wrapper, fn)  # 复制函数属性, 功能类似functools.wraps.
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__, add.__wrapped__, add.__dict__, sep='\n')  
```

## partial()

```python 
# 语法
partial(func, *args, **keywords)
```

-   该函数返回一个 partial 对象, 调用该对象的效果相当于调用 func 函数, 并传入位置参数 args 和关键字参数 keywords 。如果调用该对象时传入了位置参数，则这些参数会被添加到 args 中。如果传入了关键字参数，则会被添加到 keywords 中。 
-   也称偏函数, 把函数部分的参数固定下来, 相当于为部分的参数添加了一个固定的默认值, 形成一个新的函数并返回, 从partial生成的函数, 是对原函数的封装。

示例： 

```python 
import functools

def add(x, y, *args) -> int:
    print(args)
    return x + y

newadd = functools.partial(add, 1,3,6,5)
print(newadd(7))
print(newadd(7, 10))
# print(newadd(9, 10, y=20, x=26))  # 报错.
print(newadd())
```

## wraps()

```python 
# 语法 
functools.wraps(wrapped[, assigned][, updated])
```

`wraps()` 简化了 `update_wrapper()` 函数的调用。

它等价于 `partial(update_wrapper, wrapped=wrapped, assigned, updated=updated)`。

示例： 

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        @functools.wraps(fn)  # 属性复制.
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return wrapper
        # return functools.update_wrapper(wrapper, fn)
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__,add.__dict__, sep='\n')
```

## functools.lru_cache()

```python 
# 语法 
lru_cache(maxsize=128, typed=False)
```

>   `least-recently-used` 装饰器。 lru即最近最少使用，cache即缓存。 
>
>   如果 maxsize 设置为None, 则禁用 LRU 功能, 并且缓存可无限制增长, 当 maxsize 是2的幂的时候, LRU 功能执行得最好。  
>
>   如果 typed 设置为 True , 则不同类型的函数参数将单独缓存。例: f(3) 和 f(3.0) 将被视为具有不同结果的不同调用。

示例：斐波那契数列递归方法的改造. 

```python 
import functools

@functools.lru_cache()  # 最大限度缓存.
def fn(n):
    if n < 2:
        return n
    return fn(n-1) + fn(n-2)

print([fn(x) for x in range(100)])
```

**lru_cache装饰器应用**

>   使用前提： 
>
>   -   同样的函数参数一定得到同样的结果；
>   -   函数执行时间很长,且要多次执行。
>
>   本质是函数调用的参数 -> 返回值. 
>
>   缺点： 
>
>   -   不支持缓存过期,key无法过期 失效。
>   -   不支持清除操作。
>   -   不支持分布式,是一个单机的缓存。
>
>   适用场景, 单机上需要空间换时间的地方,可以用缓存来将计算变成快速的查询。

# 参数注解 

>   python是动态语言, 变量随时可以被赋值, 且能赋值为不同的类型; 它也不是静态编译型语言, 变量类型是在运行时决定的;  
>
>   动态语言很灵活, 但是也有弊端：  
>
>   -   难发现: 由于不做任何类型检查, 直到运行期问题才显现出来, 或者线上运行时才会暴露出问题; 
>   -   难使用: 函数的使用者看到函数的时候, 并不知道你的函数设计,不知道应该传入什么类型的数据. 
>
>   解决这种动态语言定义的弊端:   
>
>   -   增加文档Documentation String.  (`__doc__`) 
>   -   惯例, 非强制标准。 
>   -   函数定义更新与文档更新未必同步。

**函数注解**

>   python3.5引入。 
>
>   对函数的参数进行类型注解。 
>
>   只对函数参数做一个辅助说明, 并不对函数参数进行类型检查。 
>
>   提供第三方工具, 做代码分析, 发现隐藏的BUG。 
>
>   函数注解信息,保存在 __annotations__属性中. 

**变量注解** 

>   python3.6引入。 
>
>   示例：i:int = 3 

示例: 

```python 
In [1]: def func(x:int, y:int) -> int:
   ...:     return x+y
   ...:

In [2]: func.__annotations__
Out[2]: {'return': int, 'x': int, 'y': int}

In [3]:
```

**应用场合** 

-   函数参数类型检查。 

-   思路： 

    -   函数参数的检查,一定是在函数外。

    -   函数应该作为参数,传入到检查函数中。  

    -   检查函数拿到函数传入的实际参数,与形参声明对比。 

    -   `__annotations__` 属性是一个字典,其中包括返回值类型的声明。

        假设要做位置参数的判断, 无法和字典中的声明对应, 使用 `inspect` 模块。

# inspect模块:

>   提供获取对象信息的函数,可以检查函数和类、类型检查。

## signature(callable) 

>   获取函数签名, 函数签名包含了一个函数的信息, 包括函数名,它的参数类型,类和名称空间及其他信息。

```python 
In [1]: import inspect

In [2]: def add(x:int, y:int, *args, **kwargs) -> int:
   ...:     return x + y
   ...:

In [3]: sig = inspect.signature(add)

In [4]: sig
Out[4]: <Signature (x:int, y:int, *args, **kwargs) -> int>

In [5]: sig.parameters
Out[5]:
mappingproxy({'args': <Parameter "*args">,
              'kwargs': <Parameter "**kwargs">,
              'x': <Parameter "x:int">,
              'y': <Parameter "y:int">})

In [6]: sig.return_annotation
Out[6]: int

In [7]: sig.parameters['y']
Out[7]: <Parameter "y:int">

In [8]: sig.parameters['y'].annotation
Out[8]: int

In [9]: sig.parameters['args'].annotation
Out[9]: inspect._empty

In [10]:
```

与 inspect模块相关的一些 is 函数：  

```python 
inspect.isfunction(add), 是否是函数; 
isspect.ismethod(add), 是否是类的方法; 
inspect.isgenerator(add), 是否是生成器对象; 
inspect.isgeneratorfunction(add), 是否是生成器函数; 
inspect.isclass(add), 是否是类; 
inspect.ismodule(inspect), 是否是模块; 
inspect.isbuiltin(print), 是否是内建函数.
... 
还有很多is函数,需要的时候查阅inspect模块帮助.
```

## parameters 属性 

>   inspect.Signature 对象的 paramerters属性是一个mappingproxy（映射）类型的对象，值为一个有序字典（Orderdict)。
>
>   -   该有序字典里的key为参数名，str类型。
>   -   value是一个inspect.Parameter类型的对象, 这个对象里包含的一个参数的各种信息。 

parameters对象：

-   保存在元组中, 只读。
-   name为参数的名字。
-   annotation, 参数的注解, 可能没有定义。
-   default, 参数的缺省值, 可能没有定义。
-   empty, 特殊的类, 用来标记default属性或者注释annotation属性。
-   kind, 实参如何绑定到形参, 就是形参的类型。
-   POSITIONAL_ONLY, 值必须是位置参数提供。 
-   POSITIONAL_OR_KEYWORD, 值可作为关键字或者位置参数提供。
-   VAR_POSITIONAL, 可变位置参数, 对应*args。
-   KEYWORD_ONLY, keyword-only参数, 对应*或者*args之后出现的非可变关键字参数。
	   VAR_KEYWORD, 可变关键字参数, 对应**kwargs。	

```python 
In [1]: import inspect

In [2]: def add(x:int, y:int, *args, **kwargs) -> int:
   ...:     return x + y
   ...:

In [3]: isg = inspect.signature(add)

In [4]: isg
Out[4]: <Signature (x:int, y:int, *args, **kwargs) -> int>

In [5]: isg.parameters
Out[5]:
mappingproxy({'args': <Parameter "*args">,
              'kwargs': <Parameter "**kwargs">,
              'x': <Parameter "x:int">,
              'y': <Parameter "y:int">})

In [6]: isg.parameters.items()
Out[6]: odict_items([('x', <Parameter "x:int">), ('y', <Parameter "y:int">), ('args', <Parameter "*args">), ('kwargs', <Parameter "**kwargs">)])

In [7]: for i, item in enumerate(isg.parameters.items()):
   ...:     name, param = item
   ...:     print('name: {}, param: {}'.format(name, param))
   ...:     print(param.annotation, param.kind, param.default)
   ...:     print(param.default is param.empty)
   ...:
name: x, param: x:int
<class 'int'> POSITIONAL_OR_KEYWORD <class 'inspect._empty'>
True

name: y, param: y:int
<class 'int'> POSITIONAL_OR_KEYWORD <class 'inspect._empty'>
True

name: args, param: *args
<class 'inspect._empty'> VAR_POSITIONAL <class 'inspect._empty'>
True

name: kwargs, param: **kwargs
<class 'inspect._empty'> VAR_KEYWORD <class 'inspect._empty'>
True

In [8]:
```

示例：业务应用

[**示例代码**](https://github.com/amesy/PythonStudyNotes/blob/master/code/partial/%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8.py) 

示例：函数动态类型检查

**[示例代码](https://github.com/amesy/PythonStudyNotes/blob/master/code/partial/%E5%87%BD%E6%95%B0%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.py)**

# 文件操作 

## 复习 - 冯诺伊曼计算机体系结构 

 ![](http://h.hiphotos.baidu.com/baike/pic/item/a8773912b31bb051973f1da5367adab44aede020.jpg)

>   CPU由控制器和运算器组成。
>
>   -   运算器: 完成各种算数运算,逻辑运算,数据传输等数据加工处理。
>   -   控制器: 控制程序的执行。
>   -   存储器: 用于记忆程序和数据,例如内存等。
>   -   输入设备: 将数据或者程序输入到计算机中,例如键盘,鼠标等。
>   -   输出设备: 将数据或程序的处理结果展示给用户,例如显示器,打印机等。
>
>   一般的IO操作, 指文件IO, 如果指的是网络IO,都会直接说网络IO。

## 文件操作  

**文件IO常用操作:** 

>   open, read, readline, readlines, write, close, flush, next, tell, seek, writelines

**打开操作:** 

>   open(file, mode='r', buffering=-1, encoding=None, newline=None, closefd=True, opener=None) 
>
>   打开文件的模式有：
>
>   -   只读模式（默认）
>   -   只写模式（不可读，不存在则创建，存在则覆盖）
>   -   追加模式（可读，不存在则创建,存在则只追加内容）
>
>   mode模式： 
>
>   -   r : 缺省, 表示只读打开, 文件不存在或使用write方法, 会抛异常。
>   -   w : 只写打开, 读取则抛异常, 文件不存在则创建, 反之清空文件内容。
>   -   x : 创建并写入一个新文件, 以只读方式打开, 文件存在则抛异常。
>   -   a : 写入打开,文件存在则追加。
>
>
>
>   -   r+：可读写，与a+的区别是可以写到文件任何位置。
>
>   -   a+：可读写模式，写只能写在文件末尾。
>
>   -   w+：可读写，与a+的区别是要清空文件内容。
>
>       ​
>
>   -   b：二进制模式; 将文件按字节理解,与字符编码无关,二进制模式操作时,字节操作使用bytes类型。 
>
>   -   rb：二进制文件。
>
>   -   wb：二进制写, 文件存储同样被清空。
>
>       ​
>
>   -   t：缺省的,文本模式,字符流,将文件字节按某种字符编码理解,按字符操作,open的默认mode是rt。  
>
>   -   +：读写打开一个文件, 给原来只读,只写文件打开提供缺失的读或写的功能,不能单独使用。 
>
>   -   w 或 wt：文本模式写，打开前文件存储被清空。 

**读操作:**

>-   read(size = -1)   size表示读取的多少个字符或字节; 负数或者None表示读取到EOF。 
>-   readline(size = -1)   行读取,  size设置一次能读取行内几个字符或字节; 
>
>
>-   readlines(hint = -1)   多行读取, 读取所有行的列表, 指定 hint 则返回指定的行数。

**文件指针操作：** 

>   -   mode=r, 指针起始在0。 
>
>   -   mode=a, 指针起始在EOF。 
>
>   -   tell(), 显示指针当前位置。 
>
>   -   seek(offset[, whence]) , 文件指针操作。
>
>       移动文件指针位置. offset偏移多少字节, whence从哪里开始。 
>
>       **文本模式下:** 
>
>       -   whence 0 缺省值,表示从头开始, offset只能是正整数. 
>       -   whence 1 表示从当前位置, offset只接受0. 
>       -   whence 2 表示从EOF开始,offset只接受0. 
>
>       **二进制模式下:**
>
>       -   whence 0 缺省值, 表示从头开始, offset只能是正整数。 
>
>       -   whence 1 表示从当前位置, offset可正可负。 
>
>       -   whence 2 表示从EOF开始, offset可正可负。 
>
>           二进制模式支持任意起点的偏移, 从头、从尾、从中间位置开始。
>
>           向后seek可以超界,但是向前seek的时候, 不能超界, 否则抛异常。 

**写操作：** 

>   write()
>
>   -   write(s), 把字符串s写入到文件中并返回字符的个数。

**刷新操作:** 

>   flush()
>
>   -   将文件写入到硬盘。

**关闭操作: ** 

>   close()
>
>   -   flush 并关闭文件对象。 
>
>       文件已经关闭, 再次关闭没有任何效果。

**其他:** 

>   -   seekable(), 是否可seek。 
>   -   readable(), 是否可读写。 
>   -   writeable(), 是否可写。 
>   -   closed(), 是否已经关闭。

**buffering: 缓冲区** 

>    缓冲区一个内存空间,一般来说是一个 FIFO 队列,到缓冲区满了或达到阈值,数据才会 flush 到磁盘。

-   -1  表示使用缺省大小的buffer。如果是二进制模式,使用 `io.DEFAULT_BUFFER_SIZE` 值,默认是 4096 或者 8192。如果是文本模式/终端设备,则是行缓存方式, 反之则使用二进制模式策略。 
-   0  只在二进制模式使用,表示关buffer。
-   1  只在文本模式使用,表示使用行缓冲,意思是见到换行符就flush。
-   大于1用于指定buffer的大小。

总结: 

-   文本模式,一般都用默认缓冲区大小。
-   二进制模式,是一个个字节的操作,可以指定buffer的大小。 
-   一般,默认缓冲区大小是个比较好的选择,除非明确知道,否则不调用它。
-   一般编程中,明确知道需要写磁盘了,都会手动调用一次flush,而不是等到自动flush或者close的时候。

**encoding: 编码** 

>   encoding:编码, 仅文本模式使用。 
>
>   encoding表示的是返回的数据采用何种编码，一般采用utf8或者gbk。 
>
>   Nome表示使用缺省编码,依赖操作系统. 

**其他参数:** 

>   errors: 什么样的编码错误将被捕获. None和strict表示有编码错误将抛出ValueError异常; ignore表示忽略. 

>   newline: 文本模式中,换行的转换. 可以为None, '', '\r', '\n', '\r\n'.  
>
>   -   读时, None表示'\r', '\n', '\r\n'都会被转换成'\n'; ''表示不会自动转换通用换行符;其他合法字符表示换行符就是指定字符,就会按照指定字符分行；
>   -   写时, None表示'\n'都会被替换为系统缺省分隔符os.sleep; '\n'或表示'\n'不替换; 其他合法字符表示'\n'会被替换为指定的字符。  
>
>   closefd: 关闭文件描述符,True表示关闭它, False会在文件关闭后保持这个描述符。

## 上下文管理 

>   一种特殊的语法, 交给解释器去释放文件对象。 
>
>    使用with ... as关键字。  
>
>   -   上下文管理的语句并不会开启新的作用域。 
>   -   with语句执行完时, 会自动关闭文件对象。

示例：其他写法 

```python 
In [1]: f1 = open('test.txt')

In [2]: with f1:
   ...:     f1.write('abc')  # 文件只读, 写入失败。 
   ...:
---------------------------------------------------------------------------
UnsupportedOperation                      Traceback (most recent call last)
<ipython-input-2-b470ec0ee3f2> in <module>()
      1 with f1:
----> 2     f1.write('abc')
      3

UnsupportedOperation: not writable

In [3]: f1.closed  # 此时，测试发现，文件已经关闭。
Out[3]: True

In [4]:
```

对于类似于文件对象的IO对象, 一般来说都需要在不使用时关闭、注销以释放资源。IO被打开时, 会获得一个文件描述符。计算机资源有限, 所以操作系统都会做限制。

为了保护计算机的资源不被完全耗尽, 计算资源是共享的, 非独占。一般情况下, 除非特别明确知道资源情况, 否则不建议提高资源的限制值来解决此类问题。

## StringIO和BytesIO

**StringIO：**  

>   IO 模块中的类: `from io import StringIO ` 。
>
>   内存中, 开辟一个文本模式的buffer, 可以像文件对象一样操作它。
>
>   当close方法被调用时,这个buffer会被释放。 
>
>   **StringIO操作:**   
>
>   -   getvalue()  获取全部内容, 跟文件指针没有关系。 
>
>   **StringIO的好处:** 
>
>   -   一般磁盘操作比内存操作要慢很多, 内存足够情况下, 一般优化思路是少落地, 减少磁盘IO的过程, 可以大大提高程序的运行效率。

示例 : 

```python 
In [1]: from io import StringIO

# 内存中构建.
In [2]: f = StringIO()  # 像操作文件对象一样.

In [3]: f.write('hello')
Out[3]: 5

In [4]: f.write(' ')
Out[4]: 1

In [5]:  f.write('world!')
Out[5]: 6

In [6]: f.getvalue()  # 输出全部内容. 
Out[6]: 'hello world!'

In [7]:
```

**BytesIO :**   

>   io模块中的类: `from io import BytesIO`  
>
>   内存中,开辟一个二进制模式的buffer, 可以像文件对象一样操作它。 
>
>   当 close 方法被调用时, 这个 buffer 会被释放。

```python 
In [1]: from io import BytesIO

In [2]: bio = BytesIO()

In [3]: bio.readable(), bio.writable(), bio.seekable()
Out[3]: (True, True, True)

In [4]: bio.write('学习编程'.encode('utf-8'))
Out[4]: 12

In [5]: bio.getvalue()
Out[5]: b'\xe5\xad\xa6\xe4\xb9\xa0\xe7\xbc\x96\xe7\xa8\x8b'

In [6]:
```

## file-like object 

>    像`open()`函数返回的这种有个`read()`方法的对象，在Python中统称为file-like Object (类文件对象)。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个`read()`方法就行。
>
>   `StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。
>
>   类文件对象,可以像文件对象一样操作。
>
>   socket对象, 输入输出对象(stdin, stdout)都是类文件对象。

```python 
In [1]: from sys import stdout

In [2]: f = stdout

In [3]: type(f)
Out[3]: colorama.ansitowin32.StreamWrapper

In [4]: f.write('python')
python
In [5]:
```

# 路径操作 

>   在 Python3.4 之前的路径操作方式, 使用 os.path 以字符串的方式操作路径。 
>
>   在Python3.4+ 中新增了pathlib 模块来操作路径，完全采用面向对象的编程方式, 在处理配置路径方面简单高效。 

```python 
In [1]: import pathlib

# 创建Path对象，即初始化路径.
In [2]: p = pathlib.Path('/python/test') 
    
In [3]: p.is_dir()  # 判断是否是目录.
Out[3]: True
```

## 创建目录

>   使用到 mkdir 方法。

```python 
In [1]: import pathlib

In [2]: create_dir = pathlib.Path('/python/test/pathlib')  # 生成一个要创建的文件夹对象.
    
In [3]: create_dir.exists()  # 确认目录是否存在.
Out[3]: False

In [4]: create_dir.mkdir(755, parents=True, exist_ok=True)  # 创建一个 pathlib 文件夹，设置文件夹权限为755.

In [5]: pwd
Out[5]: '/python/test'

In [6]: ls -ld  pathlib  # 查看创建的文件信息.
d-wxrw--wt 0 amesy amesy 512 Mar 10 04:27 pathlib/

In [7]:
```

>   相当于 `mkdir -p` , 参数 `parents=True` 表示自动创建父目录，`exist_ok=True`  表示若目录存在则不抛任何错误, 否则抛出FileNotFoundError。 

## 删除目录

>   使用到 rmdir() 方法, 没有提供判断目录为空的方法。

```python 
In [7]: delete_dir = pathlib.Path('./pathlib')  # 生成需要删除的目录对象.

In [8]: delete_dir.rmdir()  # 删除目录，另外rmdir删除目录的话，只能删除空目录.

In [9]: ls -ld pathlib  # 确认目录已经删除.
ls: cannot access 'pathlib': No such file or directory

In [10]:
```

## 路径拼接

>   使用到操作符: '/' .
>
>   -   Path对象/Path对象. 
>   -   Path对象/字符串或者字符串/Path对象. 

```python 
In [1]: import pathlib

In [2]: p = pathlib.Path('a', 'b', 'c/d')  # 要拼接的字符串.

In [3]: p
Out[3]: PosixPath('a/b/c/d')  # 拼接后的结果.

In [4]:
```

**windows下的路径拼接**

>   注意用 print 打印, 输出结果中的路径才是反斜杠。

```python 
In [1]: import pathlib

In [2]: pathlib.PureWindowsPath('c:', 'windows', 'system32')
Out[2]: PureWindowsPath('c:windows/system32')

In [3]: print(pathlib.PureWindowsPath('c:','windows','system32'))
c:windows\system32

In [4]:
```
## 路径分解

>   使用到 parts 属性, 可以返回路径中的每一个部分。 
>

```python 
In [4]: p = pathlib.Path() / 'a'   # pathlib.Path() 等同于 p = Path('.'）.

In [5]: p
Out[5]: PosixPath('a')

In [6]: p1 = 'b' / p

In [7]: p1
Out[7]: PosixPath('b/a')

In [8]: p2 = pathlib.Path('c') / p1

In [9]: p2
Out[9]: PosixPath('c/b/a')

In [10]: p2.parts
Out[10]: ('c', 'b', 'a')

In [11]:
```

## 字符串与path对象拼接

>   使用到 joinpath 方法。 
>
>   -   joinpath(*other)    # 连接多个字符串到Path对象中。 

```python 
In [11]: p2
Out[11]: PosixPath('c/b/a')

In [12]: p2.joinpath('etc/', 'init.d/', pathlib.Path('mysqld'))  # 注意左斜杠.
Out[12]: PosixPath('c/b/a/etc/init.d/mysqld')

In [13]:
```

## 获取路径

>   str  获取路径字符串。
>
>   bytes  获取路径字符串的bytes。

```python 
In [13]: p = pathlib.Path('/usr/local')

In [14]: str(p), bytes(p)
Out[14]: ('/usr/local', b'/usr/local')

In [15]:
```

## 父目录  

>   parent  目录的逻辑父目录。 
>
>   parents  父目录序列。 

```python 
In [15]: p = pathlib.Path('/a/b/c/d/')

In [16]: p
Out[16]: PosixPath('/a/b/c/d')

In [17]: p.parent
Out[17]: PosixPath('/a/b/c')

In [18]: p.parent.parent
Out[18]: PosixPath('/a/b')

In [19]: p.parent.parent.parent
Out[19]: PosixPath('/a')

In [20]: [x for x in p.parents]
Out[20]: [PosixPath('/a/b/c'), PosixPath('/a/b'), PosixPath('/a'), PosixPath('/')]

In [21]:
```

## 其他属性

>   name  返回目录的最后一个部分。
>
>   suffix  返回目录中最后一个部分的扩展名。
>
>   stem  返回目录最后一个部分,没有后缀。
>
>   cwd()  返回当前工作目录。 
>
>   home()  返回当前家目录。 
>
>   touch(mode=0o666, exist_ok=True)   创建一个文件。
>
>   as_uri()  将路径返回成URI, 例如 'file:///etc/passwd' 。 
>
>   iterdit()  迭代当前目录。 
>
>   resolve()  返回一个新的路径, 这个新路径就是当前Path对象的绝对路径,如果是软链接则直接被解析。 
>
>   absolute()  也可以获取绝对路径,但是推荐使用resolve()。
>
>   suffixes  返回多个扩展名列表。
>
>   with_suffix(suffix)  补充扩展名到路径尾部,返回新的路径,扩展名存在则无效。
>
>   with_name(name)  替换目录最后一个部分并返回一个新的路径，不改变原路径。

```python 
In [21]: p.name
Out[21]: 'mysql.tar.gz'

In [22]: p.suffix
Out[22]: '.gz'

In [23]: p.suffixes
Out[23]: ['.tar', '.gz']

In [24]: p.stem
Out[24]: 'mysql.tar'

In [25]: p.with_name('mysql-5.tar')
Out[25]: PosixPath('/etc/mysqlinstall/mysql-5.tar')

In [26]: p.with_suffix('.gz')
Out[26]: PosixPath('/etc/mysqlinstall/mysql.tar.gz')

In [27]: p
Out[27]: PosixPath('/etc/mysqlinstall/mysql.tar.gz')

In [34]:
```

## 一些判断的方法

>   is_dir()   是否是目录; 
>
>   is_file()   是否是普通文件; 
>
>   is_symlink()   是否是软链接; 
>
>   is_socket()  是否是socket文件; 
>
>   is_block_device()  是否是块设备; 
>
>   is_char_device()   是否是字符设备; 
>
>   is_absolute()   是否是绝对路径; 
>
>   exists()   目录或文件是否存在. 

## 通配符

>   glob(pattern)   通配给定的模式。 
>
>   rglob(pattern)   通配给定的模式,递归目录。 

```python 
In [1]: import pathlib

In [2]: p = pathlib.Path()

In [3]: list(p.glob('test'))
Out[3]: []

In [4]: list(p.glob('*.py'))
Out[4]: [PosixPath('test.py')]

In [5]: list(p.glob('**/.*.py'))
Out[5]: []
```

## 匹配模式

>   match(pattern)   模式匹配,成功返回True。

```python 
In [6]: pathlib.Path('/a/b/c.py').match('b/*.py')
Out[6]: True

In [7]: pathlib.Path('/a/b/c.py').match('a/*.py')
Out[7]: False
```

## 文件操作

>   open(mode='r', buffering=-1, ending=None, errors=None, newline=None) 
>
>   使用方法类似内建函数open(), 返回一个文件对象。 
>
>   以下为 python3.5以后增加的新函数:  
>
>   -   `read_bytes()`
>
>       以 'rb' 读取路径对应文件,并返回二进制流. 具体可通过看源码知悉。 
>
>   -   `read_text(encoding=None, errors=None)`
>
>       以 'rt' 方式读取路径对应文件,返回文本。
>
>   -   `Path.write_bytes(data) `
>
>       以 'wb' 方式写入数据到路径对应文件。
>
>   -   `write_text(data, encoding=None, errors=None) `
>
>       以 'wt' 方式写入字符串到路径对应文件。

```python 
# read_bytes()
In [1]: import pathlib

In [2]: p = pathlib.Path('my_binary_file')

In [3]: p.write_bytes(b'Binary file contents')
Out[3]: 20

In [4]: p.read_bytes()
Out[4]: b'Binary file contents'

# read_text()    
In [5]: p = pathlib.Path('my_text_file')

In [6]: p.write_text('Text file contents')
Out[6]: 18

In [7]: p.read_text()
Out[7]: 'Text file contents'

# 写入文件内.
In [8]: p = pathlib.Path(r'/python/test/config.py')  # config.py文件的父目录要存在,否则会报错.

In [9]: p.write_text('hello python')
Out[9]: 12

In [10]: p.read_text()
Out[10]: 'hello python'

In [11]: with p.open() as f:
    ...:     print(f.read(5))
    ...:
hello

In [12]:
```

# os 模块 

>   **os.name**    windows是nt, linux是posix。
>
>   **os.uname()**	 Linux支持显示。 
>
>   **sys.platform**    windows显示win32, linux显示linux。  
>
>   **os.listdir('o:/temp')**    返回目录内容文件。 
>
>   os 也有 open, read, write 等方法, 但太低级,建议使用内建函数 open, read, write.  
>
>   **os.stat(path, *, dir_fd=None, follow_symlinks=True) ** 
>
>   -   调用linux系统的 stat 。 
>   -   path:  路径的string或者bytes, 后者fd。 
>   -   follow_symlinks True   返回文件本身信息, False且如果是软链接则显示软链接本身。 
>
>   **os.chown(path, uid, gid)**    改变文件的属主, 属组, 但需要足够的权限。 

```python 
In [1]: import os, sys

In [2]: os.name
Out[2]: 'posix'

In [3]: os.uname()
Out[3]: posix.uname_result(sysname='Linux', nodename='AMESY-PC', release='4.4.0-43-Microsoft', version='#1-Microsoft Wed Dec 31 14:42:53 PST 2014', machine='x86_64')

In [4]: sys.platform
Out[4]: 'linux'

In [5]: os.listdir('/python/test')
Out[5]: ['.python-version', 'config.py', 'my_binary_file', 'my_text_file', 'test.py']

In [6]: os.stat('/python/test/config.py')
Out[6]: os.stat_result(st_mode=33206, st_ino=15199648742690179, st_dev=2, st_nlink=1, st_uid=1000, st_gid=1000, st_size=12, st_atime=1520664200, st_mtime=1520664200, st_ctime=1520664200)

In [7]:
```

# shutil 模块  

目前为止, 文件的拷贝通过打开文件对象、读取源文件内容、写入目标文件中来完成拷贝过程, 但这样会丢失 stat 数据信息(权限等), 因为根本就没复制过去。此时 python 提供了一个方便的库 shutil 来操作复杂的文件或者目录。

## copy 复制 

>   `copyfileobj(fsrc, fdst[, length]) ` 
>
>   -   文件对象的复制, fsrc 和 fdst 是 open 打开的文件对象,复制内容, fdst要求可写。 
>   -   length指定了表示buffer的大小。 
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: with open('/python/test/one.txt', 'r+') as f:
>      ...:     f.write('abcd\n1234\n')
>      ...:     f.seek(0)
>      ...:     f.flush()
>      ...:     with open('/python/test/two.txt', 'w+') as f1:
>      ...:         shutil.copyfileobj(f, f1)  # 将文件f的内容复制到文件f1
>      ...:									# 使用 stat 命令可以看到, 将文件f的全部信息一同复制给了文件f1.
>
>   In [3]:
>   ```
>
>   `copyfile(src, dst, *, follow_symlinks=True)`
>
>   -   复制文件内容,不含元数据; src, dst为文件的路径字符串。
>   -   本质上调用的就是coppyfileobj, 所以不带元数据二进制内容复制。
>
>   `copymode(src,dst,*,follow_symlinks=True)`   
>
>   -   仅仅复制权限. 
>
>   `copystat(src, dst, *, follow_symlinks=True)`  
>
>   -   复制元数据,stat包含权限. 
>
>   `copy(src, dst, *, follow_symlinks=True) `  
>
>   -   复制文件内容,权限和部分元数据,不包括创建时间和修改时间。
>   -   本质上调用的是: 
>       -   copyfile(src, dst, follow_symlinks=follow_symlinks)  
>       -   copymode(src, dst, follow_symlinks=follow_symlinks) 
>   -   copy2() 比 copy() 多了复制全部元数据,但需要平台支持。
>       -   本质上调用的是:  
>           -   copyfile(src, dst, follow_symlinks=follow_symlinks) 
>           -   copystat(src, dst, follow_symlinks=follow_symlinks) 
>
>   `copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False) `
>
>   -   递归复制目录. 默认使用copy2, 也就是带更多的元数据复制。
>   -   src, dst必须是目录, src必须存在, dst必须不存在。 
>   -   ignore=func, 提供一个callable(src, names)  -> ignore_names. 提供一个函数, 它会被调用. src是源目录, names是os.listdir(src)的结果, 就是列出src中的文件名, 返回值是要被过滤的文件名的set类型数据。

## rm 删除 

>   `shutil.rmtree(path, ignore_errors=False, onerror=None)  ` 
>
>   -   递归删除一个目录以及目录内的所有内容, 如同 rm -rf 命令一样危险, 慎用。 
>   -   它不是原子操作, 有可能删除错误, 就会中断,已经删除的就删除了。
>   -   ignore_errors为true,忽略错误. 当为False或omitted时, onerror生效。 
>   -   onerror为callable,接受函数function, path和execinfo. 
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: ls dir
>   module.py
>
>   In [3]: shutil.rmtree('dir')  
>
>   In [4]: ls dir
>   ls: cannot access 'dir': No such file or directory
>
>   In [5]:
>   ```

## move 移动 

>   `move(src, dst, copy_function=copy2)` 
>
>   -   递归移动文件/目录到目标, 返回目标。 
>   -   本身使用的是 os.rename 方法。 
>   -   如果不支持 rename, 如果是目录则要先 copytree 再删除源目录。 
>   -   默认使用copy2方法。
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: shutil.move('one.txt', 'first.txt')
>   Out[2]: 'first.txt'
>
>   In [3]:
>   ```

**shutil 还支持打包功能, 生成tar并压缩, 支持zip,gz,bz,xz**。

# 序列化和反序列化 

>   为什么要序列化?
>
>   -   内存中的字典/链表如何保存到一个文件中? 
>   -   如果是自己定义的类的实例,如何保存到一个文件中? 
>   -   如何从文件中读取数据,并让它们在内存中再次变成自己对应的类的实例? 
>
>   内存中的数据要永久存储下来，就要保存到文件中，而文件是一个字节序列。 
>
>   **序列化：** 把数据从内存中变成可存储或传输的过程。 
>
>   **反序列化：**把数据从序列化的对象重新读到内存里的过程。
>
>   序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
>
>   Python提供了 `pickle` 模块来实现序列化和反序列化。 

## pickle

>   `dumps(obj, protocol=None, *, fix_imports=True) `
>
>   -   对象序列化。 
>
>   `dump(obj, file, protocol=None, *, fix_imports=True)`
>
>   -   将对象序列化到文件对象, 即存入文件。
>
>   `loads(data, *, fix_imports=True, encoding='ASCII', errors='strict') `
>
>   -   对象反序列化。
>
>   `load(file, *, fix_imports=True, encoding='ASCII', errors='strict')` 
>
>   -   将对象反序列化, 即从文件读取数据。

```python
In [1]: import pickle

In [2]: file = '/python/test/one.txt'

In [3]: with open(file, 'wb') as f:
   ...:     s1 = 99
   ...:     s2 = 'abc'
   ...:     s3 = ['a', 'b', ['c', 'd']]
   ...:     pickle.dump(s1, f)
   ...:     pickle.dump(s2, f)
   ...:     pickle.dump(s3, f)
   ...:

In [4]: with open(file, 'rb') as f:
   ...:     s = [pickle.load(f) for _ in range(3)]
   ...:     print(s)
   ...:
[99, 'abc', ['a', 'b', ['c', 'd']]]

In [5]:
```

示例：

```python 
In [1]: import pickle

# 对象序列化.    
In [2]: class Pickle:
   ...:     words = 'ABCD'
   ...:     def show(self):
   ...:         print('abcd')
   ...:

In [3]: res1 = Pickle()

In [4]: sr = pickle.dumps(res1)

In [5]: res2 = pickle.loads(sr)

In [6]: res2.show()
abcd

In [7]:
```

上面例子中，其实只保存了一个类名，因为所有其他东西都是类定义的东西, 是不变的, 所以只序列化一个Pickle类名，反序列化时找到类就可以恢复一个对象。如果是保存了类Pickle()，则反序列化时要找到Pickle类的定义，才能成功，否则就会抛异常。 

示例：pickle 序列化的应用 .

>   本地序列化的情况应用较少，大多数场景都应用在网络中。将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据进行反序列化后就可以使用了。
>
>   注意，远程接收端反序列化时必须有对应的数据类型，否则就会报错，尤其是定义类，必须远程得有。 

```python 
# 第一台节点服务器
In [1]: import pickle

In [2]: class AA:
   ...:     def __init__(self):
   ...:         self.name = 'amesy'

In [3]: res = AA()

In [4]: sr = pickle.dumps(res)

In [5]: file = '/python/test/pickle.txt'

In [6]: with open(file, 'wb') as f:
   ...:     pickle.dump(res, f)
   ...:

In [7]:
```

```python 
# 第二台节点服务器
# 将上面产生的序列化文件传送到其他节点运行,保证序列化文件是源文件。
In [1]: import pickle 

In [2]: class AA: 
   ...:     def __init__(self): 
   ...:         self.name = 'amesy' 
   ...:         

In [3]: file = '/python/test/pickle.txt' 

In [4]: with open(file, 'rb') as f: 
   ...:     a = pickle.load(f) 
   ...:     

In [5]: a.name
Out[5]: 'amesy'

In [6]: 
```

总结：现在大多数项目都不是单机或单服务, 需要通过网络将数据传送到其他节点上，此时就需要大量的序列化、反序列化。 

但问题是python程序之间还可以只用pickle解决序列化、反序列化问题；如果是跨平台跨语言跨协议, 再用pickle就不太合适了，需要公共的协议，如XML，json，protocol buffer等等。具体情况需要具体选型。

## Json 

>   JSON(JavaScript Object Notation, JS对象标记)是一种轻量级的数据交换格式, 是存储和交换文本信息的语法，类似XML。	
>
>   **Json的数据类型** 
>
>   -   值
>       -   引号引起来的字符串: 数值, string, true, false, null,object, array等,这些都是值。
>   -   字符串
>       -   由双引号包围起来的任意字符的组合,可以有转义字符。
>   -   数值: 
>       -   有正负, 有整数, 浮点数。
>   -   对象: 
>       -   无序的键值对的集合; 
>       -   格式: {key1:value1, ..., keyn:valuen}
>       -   key必须是一个字符串,需要双引号保卫这个字符串; 
>       -   value可以是任意合法的值. 
>   -   数组: 
>       -   有序的值的组合 
>       -   格式: [val1, ..., valn]  

**json模块: **

-   python 和 json : 
    -   python支持少量内置数据类型到json的转换. 
    -   True - true, False - false, None - null, str - string.
    -   int - integer, float - float, list - array, dict - object.  

-   常用方法:
    -   **load**   json解码,从文件读取数据。
    -   **loads**   json 解码。
    -   **dump**   json编码并存入文件。
    -   **dumps**   json编码。

```python 
In [1]: import json

In [2]: d = {'name':'Tom', 'age':20, 'interest':['music','movie']}

In [3]: j = json.dumps(d)

In [4]: j
Out[4]: '{"name": "Tom", "age": 20, "interest": ["music", "movie"]}'

In [5]:

In [5]: d1 = json.loads(j)

In [6]: d1
Out[6]: {'age': 20, 'interest': ['music', 'movie'], 'name': 'Tom'}

In [7]:
```

一般 json 编码的数据很少落地, 数据都是通过网络传输。传输的时候, 要考虑压缩它, 本质上来说它就是个文本, 是个字符串。
json 很简单, 几乎编程语言都支持, 所以应用很广泛。 

## MessagePack 

>   MessagePack是一个基于二进制高效的对象序列化类库, 可用于跨语言通信。它可以像 JSON 一样, 在许多语言之间交换结构数据; 但它比JSON更快更轻巧。支持很多种语言(python，java，ruby，c，golang等)。兼容json和pickle。
>
>   官网: https://msgpack.org/ 
>
>   安装: pip install msgpack-python

常用方法: 

-   **packb**   序列化对象. 提供了dumps来兼容pickle和json。
-   **unpackb**   反序列化对象, 提供了loads来兼容。  
-   **pack**   序列化对象保存到文件对象, 提供了dump来兼容。 
-   **unpack**   反序列化对象保存到文件对象, 提供了load来兼容。

```python 
In [1]: import msgpack

In [2]: d = {"person":[{"name":"tom", "age":18}, {"name":"jerry", "age":16}], "total":2}

In [3]: b = msgpack.packb(d)

In [4]: b
Out[4]: b'\x82\xa6person\x92\x82\xa4name\xa3tom\xa3age\x12\x82\xa4name\xa5jerry\xa3age\x10\xa5total\x02'

In [5]: len(b)
Out[5]: 48

In [6]: d1 = msgpack.unpackb(b, encoding='utf-8')

In [7]: d1
Out[7]:
{'person': [{'age': 18, 'name': 'tom'}, {'age': 16, 'name': 'jerry'}],
 'total': 2}

In [8]:
```

```python 
In [8]: d = [1, 2, 3]

In [9]: res1 = msgpack.packb(d)

In [10]: res1
Out[10]: b'\x93\x01\x02\x03'

In [11]: msgpack.unpackb(res1)
Out[11]: [1, 2, 3]

In [12]: res2 = msgpack.unpackb(res1, use_list=False)

In [13]: res2
Out[13]: (1, 2, 3)

In [17]:
```

**注:** 官方建议始终指定 use_list 关键字参数以实现向后兼容性。

# 面向对象

## 语言的分类 

>   1, 面向机器: 
>
>   -   抽象成机器指令,机器容易理解。
>   -   代表: 汇编语言。
>
>   2, 面向过程: 
>
>   -   问题规模小,可步骤化,按部就班处理。
>   -   代表: C语言。
>
>   3, 面向对象OOP: (Object-Oriented Programming)
>
>   -   随着计算机需要解决的问题的规模扩大,情况越发复杂,需要很多人/部门协作,OOP不太适合了。
>   -   代表: C++, Java, Python。

## 面向对象概述 

>   概念: 一种认识世界,分析世界的方法论;将万事万物抽象为类. 
>   类class: 
>
>   -   类是抽象概念,是万事万物的抽象,是一类事物的共同特征的集合; 
>   -   用计算机语言描述,就是属性和方法的集合; 
>
>   对象instance, object: 
>
>   -   对象是类的对象,是一个实体; 
>   -   对于我们每个人这个个体, 都是抽象概念人类的不同的实体. 
>
>   抽象和具象/具体: 
>
>   -   抽象: 所有能够感知到的事物对象的抽象的概念,是数据和动作的集合,对计算机而言,数据称为属性,动作称为方法.
>   -   具象/具体: 真实发生的动作,如吃饭,等.
>
>   属性,是独享状态的抽象,用数据结构来描述.
>   操作,是对象行为的抽象,用操作名和实现该操作的方法来描述.
>
>   哲学: 
>
>   -   一切皆文件; 
>   -   对象是数据和操作的封装; 
>   -   对象是独立的,但是对象之间可以相互作用; 
>   -   目前OOP是最接近人类认知的编程范式.
>
>   面向对象三要素: 
>
>   1, **封装**
>
>   -   组装: 将数据和操作组装到一起; 
>
>       隐藏数据: 对外只暴露一些接口,通过接口访问对象; 
>
>   2, **继承**
>
>   -   多复用,继承来的就不用自己写了; 
>
>       多继承少修改,OCP(Open-closedPrinciple),使用继承来改变,来体现个性; 
>
>   3, **多态**
>
>   -   面向对象编程最灵活的地方,动态绑定.

总结：

-   面向对象：对函数进行分类和封装，让开发“更快更好更强.任何事物都可以抽象成类,面向对象编程就是对"类"和"对象"的使用.

-   类：就是一个模板, 模板里可以包含多个函数, 函数里实现一些功能; 对象则是根据模板创建的实例, 通过实例对象可以执行类中的函数. 

-   封装：顾名思义就是将内容封装到某个地方，以后再去调用被封装在该处的内容。

-   继承：面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。

-   对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。

-   Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先. 

    -   当类是经典类时，多继承情况下，会按照深度优先方式查找。
    -   当类是新式类时，多继承情况下，会按照广度优先方式查找。

-   问题一：什么样的代码才是面向对象？

    从简单来说，如果程序中的所有功能都是用 类 和 对象 来实现，那么就是面向对象编程了。

-   问题三：类和对象在内存中是如何保存？    

    类以及类中的方法在内存中只有一份，而根据类创建的每一个对象都在内存中需要存一份。 

## python的类 

>   必须使用 class 关键字, 类名必须用大驼峰命名, 类定义完成后就产生了一个类对象, 绑定到了 ClassName 上。
>
>   类本身也是对象, 而且是一切皆对象。 
>
>   类对象: 自身是类,也是对象。
>
>   类的对象: 类的实例, 实体。 

```python 
In [1]: class MyClass:
   ...:     '''A example class'''
   ...:     x = 'abc'  # 类属性, 类变量.
   ...:     def foo(self):  # 类属性foo,也是方法. 
   ...:         return 'My class'
   ...:

In [2]: MyClass.x
Out[2]: 'abc'

In [3]: MyClass.foo
Out[3]: <function __main__.MyClass.foo>

In [4]: MyClass.__doc__
Out[4]: 'A example class'
```

>   类对象 
>
>   -   类的定义就会生成一个类对象; 
>
>   类属性
>
>   -   类定义中的变量和类中定义的方法都是类的属性; 
>
>   类变量 
>
>   -   上例中的x是类MyClass的变量;
>
>   MyClass中, x 和 foo 都是类的属性, `__doc__`也是类的属性; 
>   foo 方法是类的属性,如同吃是人类的方法,但是每一个具体的人才能吃东西,也就是说吃是人的实例才能调用的方法。
>   foo 是方法对象,不是普通的函数对象, 它必须至少有一个参数, 且第一个参数必须是self(self可以改名), 这个位置参数就留给self. 
>   self指代当前实例本身.

### 实例化 

```python 
a = MyClass()
```

-   实例化即真正创建一个该类的对象(实例)。 
-   实例化后获得的实例, 是不同的实例, 即使是使用同样的参数实例化, 也会得到不一样的对象。
-   python类实例化后, 会自动调用 `__init__` 方法。该方法第一个参数必须留给self, 其他参数随意。
-   类需要实例化之后, 用创建出来的实例来操作方法。

### `__init__` 方法   

-   MyClass() 实际上调用的是 `__init__(self)` 方法, 可以不定义, 如果没有定义会在实例化后隐式调用。 
-   作用：对实例进行**初始化**。 



```python 
class MyClass:
    def __init__(self, name, age):
        self.name = name 
        self.age = age
        print('init')
    def show_age(self):
        pass

info = MyClass()  # 会调用 __init__
```

>   -   初始化函数可以有多个参数, 注意第一个位置必须是self, 例如 `__init__(self, name, age)` 。
>   -   `__init__()` 方法返回值只能是None, 即如果要使用return，只能 return None, 当然它默认就是 return None。
>   -   python中创建的两个对象,不可能完全相等,因为两个个体是两个不同的内存地址。

### 实例对象 instance 

>   类实例化后一定会获得一个对象,就是实例对象。 
>
>   `__init__` 方法的第一个参数就是指代某一个实例。
>
>   **类实例化出一个实例对象,实例对象会绑定方法** 。如上代码, 调用方法时会采用该方式: `info.show_age()`  。
>
>   `show_age(self)` 中的 self 就是实例化变量 info。Python会把方法的调用者作为第一参数 self 的实参传入。
>
>   `self.name` 就是 info 对象的 name。name 保存在了info 对象上, 而不是 MyClass 类上, 所以称为实例变量。

### self 

```python 
In [1]: class MyClass:
   ...:     def __init__(self):
   ...:         print(id(self))
   ...:

In [2]: res = MyClass()
140196345123616

In [3]: id(res)
Out[3]: 140196345123616

In [4]:
```

上例说明, self就是调用者, 即 res 对应的实例对象。
self 这个名字只是一个惯例, 它可被修改。但不建议修改,否则会影响代码的可读性。 

### 实例变量和类变量

```python 
In [1]: class Person:
   ...:     age = 3
   ...:     def __init__(self, name):
   ...:         self.name = name
```

如上代码, **实例变量是每一个实例自己的变量,是自己独有的, 如self.name; 类变量是类的变量,是类的所有实例共享的属性和方法, 如age=3; ** 

| 特殊属性       | 含义             |
| -------------- | ---------------- |
| `__name__`     | 对象名           |
| `__class`      | 对象的类型       |
| `__dict__`     | 对象的属性的字典 |
| `__qualname__` | 类的限定名       |

`__qualname__` 是类的类型的限定名, 在类的实例下才有, 自己定义的实例下没有；限定名不等于name。

类属性保存在类的 `__dict__` 中, 实例属性保存在实例的`__dict__` 中,如果从实例访问类的属性,就需借助 `__class__` 找到所属的类。 

对象的方法没必要定义在对象里, 各操作一样,即所有的方法操作对象是一样的,只是数据不同; 函数也是,所有对象的操作一样,只是传的参数不同。	

```python 
In [2]: Person.__qualname__
Out[2]: 'Person'

In [3]: Person.__name__
Out[3]: 'Person'

In [4]: Person.__class__
Out[4]: type

In [5]: Person.__dict__
Out[5]:
mappingproxy({'__dict__': <attribute '__dict__' of 'Person' objects>,
              '__doc__': None,
              '__init__': <function __main__.Person.__init__>,
              '__module__': '__main__',
              '__weakref__': <attribute '__weakref__' of 'Person' objects>,
              'age': 3})

In [6]:
```

**总结：**

-   属于类的,也是这个类所有实例的, 它的实例都可以访问的到；属于实例的, 就是这个实例自己的, 通过类访问不到。
-   类变量是属于类的变量, 这个类的所有实例可以共享这个变量。
-   实例可以动态的给自己增加一个属性：`实例.__dict__[变量名]` 和 `实例.变量名` 都可以访问到。
-   实例的同名变量会隐藏这类变量，或者说是覆盖了这个类变量。

**实例属性的查找顺序：**

>   指的是实例使用 `.` 来访问属性, 会先找自己的 `__dict__` , 如果没有, 就会通过属性 `__class__` 找到自己的类, 再去类的__dict__中找。 注: 如果实例使用__dict__[变量名]访问变量,将不会按照上面的查找顺序找变量了。  
>
>   一般, 类变量使用全大写来命名。

### `__slots__` 限定实例属性

>   正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。为了给所有实例都绑定方法，可以给class绑定方法，然后所有实例均可调用。通常实例的方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。
>
>   如果想要限制实例的属性怎么办？比如，只允许对 Student 实例添加 name 和 age 属性。
>   为了达到限制的目的，Python允许在定义class时定义一个特殊的 `__slots__` 变量，来限制该class实例所能添加的属性。

```python 
In [1]: class Person:
   ...:     __slots__ = ('name', 'age')
   ...:

In [2]: Person().name = 'amesy'

In [3]: Person().age = 23

In [4]: Person().sex = 'male'  # 报错, AttributeError: 'Person' object has no attribute 'sex'.
```

注意： 

-   `__slots__` 定义的属性仅对当前类实例起作用, 对继承的子类不起作用。
-   除非在子类中也定义 `__slots__` , 这样子类实例允许定义的属性就是自身的 `__slots__` 加上父类的 `__slots__` 。

### 装饰一个类

>   为一个类通过装饰,增加一些类属性。 

```python 
def foo(name): 
	def wrap(fm): 
		fm.NAME = name 
		return fm 
	return wrap
	
@foo('Tom')
class Person: 
	AGE = 23 

print(Person.AGE)
print(Person.NAME)	
```

>   之所以能够修饰,本质上是为类对象动态的添加了一个属性,而Person这个标识符指向这个类对象。

### 类方法和静态方法 

**类方法**

>   -   在类定义中,以self作为第一个参数的方法都是实例方法（instance method）。当它被调用时,Python会把调用该方法的对象作为self参数传入。
>   -   与之相对，类方法（class method）会作用于整个类，对类作出的任何改变都会对它的所有实例对象产生影响。
>   -   在类定义内部,用前缀修饰符 `@classmethod` 指定的方法都是类方法。
>   -   与实例方法类似，类方法的第一个参数是类本身。在Python中，这个参数常被写作cls，因为全称class是保留字，在这里无法使用。
>
>   前面的例子中定义的 `__init__` 等方法, 这些方法本身都是类的属性,第一个参数必须是self,而self必须指向一个对象,也就是类必须实例化后, 由实例来调用这个方法。 

示例：普通方法的调用 

```python 
In [1]: class Person:
   ...:     def normal_method():
   ...:         print('normal method')
   ...:

In [2]: Person.normal_method
Out[2]: <function __main__.Person.normal_method>

In [3]: Person.normal_method()
normal method

In [4]:
```

示例：调用类方法 

```python 
In [1]: class Person:
   ...:     @classmethod
   ...:     def class_method(cls):
   ...:         print('class method')
   ...:         cls.name = 'amesy'
   ...:

In [2]: Person.class_method()
class method

In [3]: Person.name
Out[3]: 'amesy'

In [4]: Person.__dict__
Out[4]:
mappingproxy({'__dict__': <attribute '__dict__' of 'Person' objects>,
              '__doc__': None,
              '__module__': '__main__',
              '__weakref__': <attribute '__weakref__' of 'Person' objects>,
              'class_method': <classmethod at 0x28181af3a20>,
              'name': 'amesy'})

In [5]:
```

总结： 

-   在类定义中,使用@classmethod装饰器装饰的方法; 

-   必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身; 

-   cls这个标识符可以是任意合法名称,但为了易读,不建议修改. 

-   通过cls可以直接操作类的属性. 

    注: 无法通过cls操作类的实例. 
    类方法,类似于c++, java中的静态方法。 

**静态方法** 

>   -   静态方法出现在类的定义中仅仅是为了方便, 既不会影响类也不会影响类的对象。否则它们只能孤零零地出现在代码的其他地方,这会影响代码的逻辑性。
>   -   静态方法(static method)用 `@staticmethod` 修饰, 它既不需要 self 参数也不需要 class 参数, 当然传入参数也是没问题的。
>   -   静态方法, 只是表明该方法属于这个名词空间. 函数归在一起, 方便组织管理。

```python 
In [1]: class Person:
   ...:     @staticmethod
   ...:     def static_method():
   ...:         print('static method')
   ...:

In [2]: Person.static_method()
static method
```

### 方法的调用 

-   类除了普通方法外都可以调用,普通方法需要对象的实例作为第一参数。
-   实例可以调用所有类中定义的方法(包括类方法,静态方法), 普通方法传入实例自身, 静态方法和类方法需要找到实例的类。

### 访问控制 

-   私有方法的本质: 
    -   单下划线的方法只是开发者之间的约定, 解释器不做任何改变, 称为保护变量。
    -   双下划线的方法, 是私有方法，也称私有变量。 解释器会改名, 改名策略和私有变量相同，即 `_类名__方法名`。 
    -   方法变量都在类的 `__dict__` 中可以找到。一旦获知私有变量的新名称, 就可以直接从外部访问到, 并可以修改它。
-   私有成员的总结: 
    -   在python中使用单下划线或者双下划线来标识一个成员被保护或者被私有化隐藏起来。
    -   不管使用什么样的访问控制, 都不能真正的阻止用户修改类的成员。python中没有绝对的安全的保护成员或者私有成员。
    -   前导的下划线只是一种警告或提醒, 请遵守这个约定. 除非真有必要, 不要修改或者使用保护成员或者私有成员, 更不要修改它们。

### 猴子补丁 

>   可以通过修改或者替换类的成员，使用者调用的方式没有改变, 但是类提供的功能可能已经改变。
>   猴子补丁，即在运行时,对属性进行动态替换。 
>   属于一种黑魔法, 慎用。

代码示例  --> 

### 属性装饰器 

在绑定属性时，如果直接把属性暴露出去，虽然写起来很简单，但是没办法检查参数，导致可以把成绩随便改。

```python 
s = Student()
s.score = 9999
```

这显然不合逻辑。为了限制 score 的范围，可以通过一个`set_score()`方法来设置成绩，再通过一个`get_score()`来获取成绩。这样在`set_score()`方法里，就可以检查参数： 

```python 
class Student(object):

    def get_score(self):
        return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

以上方法略显复杂，没有直接用属性这么直接简单。

此时就可以用到python内置的属性装饰器 `property`, 它负责把一个方法变成属性调用。

>   property装饰器: 
>
>   -   后面跟的函数名就是以后的属性名,即getter,这个必须有,有了它至少是只读属性. 将方法变成了属性，通过.(点)访问它.
>
>   setter装饰器: 
>
>   -   与属性名同名,且接收2个参数,第一个是self,第二个是将要赋值的值,有了它,属性可写. 
>
>   deleter装饰器: 
>
>   -   可以控制是否删除属性;很少用. 
>
>   property装饰器必须在前,setter和deleter装饰器在后. 
>   Property装饰器能通过简单的方式,把对方的操作变成对属性的访问,并起到了一定隐藏效果.
>
>   描述符：
>   `name = property(get_name, set_name, del_name, 'help...')`

示例：

```python 
class Person:
    def __init__(self, name, age=18):
        self.name = name
        self.__age = age

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, age):
        self.__age = age

    @age.deleter
    def age(self):
        # del self.__age
        print('deleter')

tom = Person('Tom')
print(tom.age)
tom.age = 20
print(tom.age)
del tom.age 
# print(tom.age)
```

示例：描述符的写法 

```python 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def getage(self):
        return self.__age

    def setage(self, age):
        self.__age = age

    def delage(self):
        del self.__age
        print('already del')

    age = property(getage, setage, delage, 'property ...')

info = Person('tom', 20)
print(info.age)
info.age = 23
print(info.age)
del info.age
# print(info.age)
```

示例：函数传参的写法

```python 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    age = property(lambda self: self.__age)

info = Person('amesy', 18)
print(info.age)
```

注：

-   如果没有指定某一特性的setter属性, 则将无法从类的外部对它的值进行设置。这对于那些只读的特性非常有用。
-   与直接访问特性相比，使用property还有一个优势：如果改变了某个特性的定义，只需要在类定义里修改相关代码即可，不需要在每一处调用修改。 

### 对象的销毁 

>   -   类中可以定义 `__del__` 方法, 称为析构函数(方法)。
>   -   作用: 销毁类的实例的时候调用, 以释放占用的资源。
>   -   由于python实现了垃圾回收机制, 这个方法不能确定何时执行; 有必要时, 使用del语句删除实例, 来手动调用这个方法。

```python 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def __del__(self):
        print(self.name)

info = Person('amesy', 18)
del info
```

### 方法重载

-   在其他面向对象的高级语言中,都有重载的概念; 
    -   重载,即同一方法名,但参数数量,类型不一样,就是同一个方法的重载.
-   python没有重载, 也不需要重载。
    -   python在方法(函数)定义形参中, 非常灵活, 不需要指定类型(就算指定了也只是一个说明而非约束), 参数个数也不固定(可变参数).  
    -   一个函数的定义可以实现很多种不同形式实参的调用。所以python不需要方法的重载。

### 封装

```
封装(Encapsulation), 即面向对象三要素之一。
封装, 即把数据和操作组织到类中,即属性和方法。
将数据隐藏起来,给使用者提供操作;使用者通过操作就可以获取或者修改数据,getter和setter。
通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来;保护成员或私有成员。
注意方法的第一个参数：self。
类中的数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
封装的另一个好处是可以给类增加新的方法。
```

### 经典类和新式类

>    python2 中为了兼容, 分为经典类(旧式类) 和 新式类。 
>
>   python3 中默认全都是新式类, 不必显式的继承object 。
>
>   新式类都继承自object, 可以使用super。  
>
>   区别： 
>
>   -   多继承时, 新式类会按广度优先(c3算法)的方式查找；经典类按照深度优先的方式查找。
>   -   新式类更符合OOP编程思想，统一了python中的类型机制。
>   -   新式类可以使用super, 旧类不适用。
>   -   新式类和旧类的类型不一样。新式类对象可以直接通过 `__class__` 属性获取自身类型: type 。
>   -   Python 2.x中默认都是经典类，除非显式继承object，只有显式继承了 object 才是新式类Python。  
>   -   新式类的实例执行 `a.__class__` 与 `type(a)` 的结果是一致的，对于旧式类来说就不一样了。  
>   -   新式类增加了 `__slots__` 内置属性, 可以把实例属性的种类锁定到` __slots__` 规定的范围之中。 
>   -   新式类增加了 `__getattribute__ ` 方法。

写法:

```python 
class A:  # A是旧式类，因为没有显示继承object.
    pass

class B(A):  # B是旧式类，因为B的基类A是旧式类.
    pass
定义新式类的方式：

class A(object):  # A是新式类，因为显式继承object.
    pass

class B(A):  # B是新式类，因为B的基类A是新式类.
    pass
```

示例 - 多继承查找 

```python 
class A():
    def __init__(self):
        pass
    def save(self):
        print "This is from A"
class B(A):
    def __init__(self):
        pass
class C(A):
    def __init__(self):
        pass
    def save(self):
        print  "This is from C"
class D(B,C):
    def __init__(self):
        pass
fun =  D()
fun.save()

经典类的答案： This is from A
新式类的答案： This is from C
```

## 类的继承

```python 
继承 (Inheritance) 是面向对象的三要素之一。
人类和猫类都继承自动物类. 
个体继承自父母,继承了父母的一部分特征,但也可以有自己的特性; 
在面向对象的世界中,从父类继承就会直接拥有父类的属性和方法,这样可以减少代码,多复用;子类可以定义自己的属性和方法. 
继承最大的好处是子类获得了父类的全部功能，其次是多态。
```

格式： 

```python 
class 子类名(基类1[,基类2,...]): 
    语句块 
```

几个名词： 

-   父类,也称为基类,超类. 
-   子类,也称为派生类. 

如果类定义时, 没有基类列表, 等同于继承自object; 在python3中, object类是所有对象的根基类。如下：

```python 
class A: 
	pass 

# 等价于: 
class A(object): 
	pass
```

python支持多继承, 继承也可以多级。
查看继承的特殊属性和方法： 

| 特殊的属性和方法   | 含义                           |
| ------------------ | ------------------------------ |
| `__base__`         | 类的基类                       |
| `__bases__`        | 类的基类元组                   |
| `__mro__`          | 显示方法的查找顺序, 基类的元组 |
| mro() 方法         | 同上                           |
| `__subclasses__()` | 类的子类列表                   |

mro: method resulation ordered 方法解析顺序。 

### 继承中的访问控制 

从父类继承,自己没有的,就可以到父类中找. 
私有的都是不可以访问的,但本质上依然是改了名称放在这个属性所在类的__dict__中. 知道这个新名称就可以直接找到这个隐藏的变量,这是个黑魔法技巧,需慎用. 

总结: 
继承时,公有的子类和实例都可以随意访问,私有成员被隐藏,子类和实例不可直接访问;私有变量所在的类中的方法可以访问这个私有变量. 
python通过自己一套实现,实现和其他语言一样的面向对象的继承机制.  

属性查找顺序: 
实例的 __dict__  -> 类 __dict__ 有继承 -> 父类 __dict__  
如果搜索这些地方后没有找到就会抛异常,先找到就会立即返回. 



（完.）









